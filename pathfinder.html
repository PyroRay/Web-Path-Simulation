<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Pathfinding Simulation</title>
    <style>
      canvas {
        border: 1px solid black;
        background-color: #f4f4f4;
      }
      body {
        font-family: sans-serif;
      }
    </style>
  </head>
  <body>
    <h2>Pathfinding Simulation (Graph-Based)</h2>
    <canvas id="canvas" width="800" height="600"></canvas>
    <p>
      Click and drag to draw walls. Press "s" to set start, "g" to set goal, and
      "w" to draw more walls.
    </p>
    <p>Press "Enter" to generate graph.</p>

    <script>
      const canvas = document.getElementById("canvas");
      const ctx = canvas.getContext("2d");

      const obstacles = [];
      const nodes = [];
      const edges = [];

      let mode = "wall"; // 'start', 'goal'
      let startNode = null;
      let goalNode = null;

      let isDrawing = false;
      let startX, startY;

      canvas.addEventListener("mousedown", (e) => {
        const rect = canvas.getBoundingClientRect();
        startX = e.clientX - rect.left;
        startY = e.clientY - rect.top;
        isDrawing = true;
      });

      canvas.addEventListener("mouseup", (e) => {
        if (!isDrawing) return;
        isDrawing = false;
        const rect = canvas.getBoundingClientRect();
        const endX = e.clientX - rect.left;
        const endY = e.clientY - rect.top;
        const x = Math.min(startX, endX);
        const y = Math.min(startY, endY);
        const w = Math.abs(startX - endX);
        const h = Math.abs(startY - endY);

        if (mode === "wall") {
          obstacles.push({ x, y, width: w, height: h });

          // Push obstacle corners as nodes
          const corners = [
            { x: x, y: y },
            { x: x + w, y: y },
            { x: x, y: y + h },
            { x: x + w, y: y + h },
          ];
          for (const corner of corners) {
            nodes.push({
              ...corner,
              id: nodes.length,
              parentWall: obstacles.length,
            }); // assign wall index
          }
        } else if (mode === "start" || mode === "goal") {
          const node = { x: x + w / 2, y: y + h / 2, id: nodes.length };
          nodes.push(node);
          if (mode === "start") startNode = node;
          if (mode === "goal") goalNode = node;
        }

        draw();
      });

      document.addEventListener("keydown", (e) => {
        if (e.key === "s") mode = "start";
        else if (e.key === "g") mode = "goal";
        else if (e.key === "w") mode = "wall";
        else if (e.key === "Enter") {
          console.log("Beginning building of graph");
          buildGraph();
          console.log("Beginning drawing");
          draw();
        }
      });

      function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Draw obstacles
        ctx.fillStyle = "black";
        for (let obs of obstacles) {
          ctx.fillRect(obs.x, obs.y, obs.width, obs.height);
        }

        // Draw edges
        ctx.strokeStyle = "red";
        for (let edge of edges) {
          ctx.beginPath();
          ctx.moveTo(edge.from.x, edge.from.y);
          ctx.lineTo(edge.to.x, edge.to.y);
          ctx.stroke();
        }

        // Draw nodes
        for (let node of nodes) {
          ctx.fillStyle =
            node === startNode ? "green" : node === goalNode ? "red" : "blue";
          ctx.beginPath();
          ctx.arc(node.x, node.y, 5, 0, Math.PI * 2);
          ctx.fill();
        }
      }

      function buildGraph() {
        edges.length = 0;

        for (let i = 0; i < nodes.length; i++) {
          for (let j = i + 1; j < nodes.length; j++) {
            const nodeA = nodes[i];
            const nodeB = nodes[j];

            const sameWall =
              nodeA.parentWall !== undefined &&
              nodeB.parentWall !== undefined &&
              nodeA.parentWall === nodeB.parentWall;

            // Allow edge if not from the same wall, OR if from same wall and adjacent
            let allow = true;

            if (sameWall) {
              const dx = Math.abs(nodeA.x - nodeB.x);
              const dy = Math.abs(nodeA.y - nodeB.y);
              const alignedHorizontally = dx > 0 && dy === 0;
              const alignedVertically = dy > 0 && dx === 0;

              // Only allow direct edge-aligned connections
              if (!(alignedHorizontally || alignedVertically)) {
                allow = false;
              }
            }

            if (allow && isVisible(nodeA, nodeB)) {
              edges.push({ from: nodeA, to: nodeB });
              edges.push({ from: nodeB, to: nodeA });
            }
          }
        }
      }
      function isVisible(a, b) {
        for (let obs of obstacles) {
          if (lineIntersectsRect(a, b, obs)) return false;
        }
        return true;
      }
      function lineIntersectsRect(a, b, r) {
        // First, check if the segment intersects any of the 4 edges of the rectangle
        const topLeft = { x: r.x, y: r.y };
        const topRight = { x: r.x + r.width, y: r.y };
        const bottomLeft = { x: r.x, y: r.y + r.height };
        const bottomRight = { x: r.x + r.width, y: r.y + r.height };

        const edges = [
          [topLeft, topRight], // top
          [topLeft, bottomLeft], // left
          [topRight, bottomRight], // right
          [bottomLeft, bottomRight], // bottom
        ];

        for (let [p1, p2] of edges) {
          if (lineIntersectsLine(a, b, p1, p2)) {
            console.log("Edge intersect detected.");
            return true;
          }
        }

        // NEW: Check if the segment passes through the interior
        // This handles the diagonal visibility issue (e.g., corner-to-corner across a wall)
        const minX = r.x;
        const maxX = r.x + r.width;
        const minY = r.y;
        const maxY = r.y + r.height;

        // If either point is inside the rect, it's definitely intersecting
        if (pointInRect(a, r) || pointInRect(b, r)) {
          console.log("Point inside rectangle â€” intersection.");
          return true;
        }

        // Otherwise, check for full segment crossing rectangle interior
        if (
          ((a.x < minX && b.x > maxX) || (b.x < minX && a.x > maxX)) &&
          ((a.y < minY && b.y > maxY) || (b.y < minY && a.y > maxY))
        ) {
          console.log("Segment crosses through the rectangle's interior.");
          return true;
        }

        return false;
      }

      function lineIntersectsLine(a1, a2, b1, b2) {
        // Check if line segments (a1-a2) and (b1-b2) intersect
        const det =
          (a2.x - a1.x) * (b2.y - b1.y) - (a2.y - a1.y) * (b2.x - b1.x);
        if (det === 0) return false; // parallel

        const lambda =
          ((b2.y - b1.y) * (b2.x - a1.x) + (b1.x - b2.x) * (b2.y - a1.y)) / det;
        const gamma =
          ((a1.y - a2.y) * (b2.x - a1.x) + (a2.x - a1.x) * (b2.y - a1.y)) / det;

        return 0 < lambda && lambda < 1 && 0 < gamma && gamma < 1;
      }

      function pointInRect(p, r) {
        return (
          p.x > r.x && p.x < r.x + r.width && p.y > r.y && p.y < r.y + r.height
        );
      }

      draw();
    </script>
  </body>
</html>
